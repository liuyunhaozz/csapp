# Bomb lab 思路

- `phase_1` 根据长度比较函数找到待输入字符串的长度，再找到正确字符串的首地址，寻址后得到正确字符串的ASCII码，映射后得到正确字符串
- `Phase_2` `disas read_from_six_numbers` 函数可以得到该函数是用了 `sscanf` 函数将字符串中的数字字符存到 `6` 个整数变量中，随后这些变量被储存在栈上。再分析后面的代码可知第一个数字是 `1`，后面是循环递归逻辑
- `phase_3` 与第二题类似，区别在于答案有多个，其中第一个数字可以是 `0-7` 的任意一个，根据这个数继续分析可以得到后面应填的值
- `phase_4` 与前两题类似，待输入的两个数第二个 `0` 直接给出，第一个数分析  `func_4`  函数可知当值为 `7`  时可以刚好避免函数的自身递归，最后可以返回正确的值
- `phase_5` 的关键是自带的两个数组，其中一个数组是值固定的基准数组，我们需要根据这个数组的取值找到和它相等的项在另一个数组中的位置，这个位置相对于基地址的偏移量就是输入字符串ascii编码的后四位，找到六个字符的后四位后我们可以根据 `ascii` 表选取出答案，由于不同的字符可以拥有相同的后四位，因此该题答案不唯一

---

`phase_6` 的代码量最长，主要分为几个逻辑

- 从 ` stdin` 中读取 `6` 个整数
- 遍历，确定每个数的范围为 $[1, 6]$ ，且这  `6 ` 个数两两不相等
- 将这 `6` 个整数做 $f:x\rightarrow7-x$ 的映射
- 创立了一个类似于链表的数据结构，基地址对应一个数，且基地址 + 8 寻址后对应下一个地址。根据数字 `1-6` 将不同的地址存储在栈上
- 将栈上第 `2` 个地址赋给栈上第 `1` 个地址所指向的地址，依次类推，最后将栈上第 `6` 个地址赋给栈上第 `5` 个地址所指向的地址，一共 `5` 次赋值。最后将栈上第 `6` 个地址所指向的地址赋为 `0`（没必要？）
- 从栈上第一个地址开始，如果栈上第一个地址所对应的数不小于这个地址所指向的地址所对应的数，则炸弹不爆炸，依次类推，一共 `5` 次比较

由此，我们只需要将 `6` 个地址所对应的数由大到小排序，再做 $f$ 的逆映射即可得到答案